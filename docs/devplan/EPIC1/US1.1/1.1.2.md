# [1.1.2] Criar publisher no backend para acionar ingest√£o manualmente

---

## üéØ Objetivo

Criar um **backend FastAPI** que permita acionar a ingest√£o manualmente atrav√©s de endpoints REST:

1. **Backend FastAPI** com estrutura organizada
2. **Publisher RabbitMQ** para enviar mensagens √† fila `ingest.pncp`
3. **Endpoints de controle** para acionar ingest√£o
4. **Valida√ß√£o de par√¢metros** com Pydantic
5. **Integra√ß√£o com Docker Compose** existente

### Endpoints a Implementar

| Endpoint | M√©todo | Descri√ß√£o |
|----------|--------|-----------|
| `POST /sync/force` | POST | For√ßar execu√ß√£o da ingest√£o |
| `GET /sync/status` | GET | Status da √∫ltima execu√ß√£o |

### Mensagens Aceitas pelo Publisher

| Modo | Payload | Descri√ß√£o |
|------|---------|-----------|
| **Update** | `{"mode":"update"}` | Processar √∫ltimos 15 minutos |
| **Backfill** | `{"mode":"backfill", "data_ini":"YYYY-MM-DDTHH:MM:SS", "data_fim":"YYYY-MM-DDTHH:MM:SS"}` | Processar intervalo espec√≠fico |

> **Foco**: Backend REST, publisher RabbitMQ e integra√ß√£o com o servi√ßo de ingest√£o existente. A l√≥gica de ingest√£o j√° foi implementada na tarefa 1.1.3.

---

## üìã Especifica√ß√µes T√©cnicas

### **1. Estrutura do Backend**

```text
pncp_ingestion_service/
‚îú‚îÄ‚îÄ backend/                    # NOVO: Backend FastAPI
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sync.py            # Endpoints /sync/*
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sync.py            # Modelos Pydantic
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ publisher.py       # Publisher RabbitMQ
‚îÇ   ‚îú‚îÄ‚îÄ config.py              # Configura√ß√£o backend
‚îÇ   ‚îî‚îÄ‚îÄ main.py                # Aplica√ß√£o FastAPI
‚îú‚îÄ‚îÄ ingestor/                  # J√Å EXISTE: Servi√ßo de ingest√£o
‚îú‚îÄ‚îÄ docker-compose.yaml        # ATUALIZAR: Adicionar backend
‚îî‚îÄ‚îÄ requirements-backend.txt   # NOVO: Depend√™ncias do backend
```

### **2. Modelos Pydantic**

```python
from pydantic import BaseModel, validator
from typing import Optional, Literal
from datetime import datetime

class SyncRequest(BaseModel):
    mode: Literal["update", "backfill"] = "update"
    data_ini: Optional[str] = None  # Obrigat√≥rio apenas para backfill
    data_fim: Optional[str] = None  # Obrigat√≥rio apenas para backfill
    
    @validator('data_ini', 'data_fim')
    def validate_backfill_params(cls, v, values):
        if values.get('mode') == 'backfill':
            if not v:
                raise ValueError('data_ini e data_fim s√£o obrigat√≥rios para modo backfill')
        return v

class SyncResponse(BaseModel):
    success: bool
    message: str
    request_id: Optional[str] = None
```

### **3. Publisher RabbitMQ**

```python
import aio_pika
import json
from typing import Dict, Any

class RabbitMQPublisher:
    def __init__(self, url: str):
        self.url = url
        self.connection = None
        self.channel = None
    
    async def connect(self):
        """Conecta ao RabbitMQ"""
        self.connection = await aio_pika.connect_robust(self.url)
        self.channel = await self.connection.channel()
    
    async def publish_sync_request(self, request: SyncRequest) -> bool:
        """Publica mensagem na fila ingest.pncp"""
        
        if request.mode == "update":
            message = {"mode": "update"}
        else:  # backfill
            message = {
                "mode": "backfill",
                "data_ini": request.data_ini,
                "data_fim": request.data_fim
            }
        
        # Publicar na fila
        await self.channel.default_exchange.publish(
            aio_pika.Message(
                body=json.dumps(message).encode(),
                delivery_mode=aio_pika.DeliveryMode.PERSISTENT
            ),
            routing_key="ingest.pncp"
        )
        
        return True
```

### **4. Endpoints FastAPI**

```python
from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse

app = FastAPI(title="PNCP Sync API", version="1.0.0")

@app.post("/sync/force")
async def force_sync(request: SyncRequest):
    """For√ßa execu√ß√£o da ingest√£o"""
    try:
        # Validar par√¢metros
        if request.mode == "backfill":
            if not request.data_ini or not request.data_fim:
                raise HTTPException(
                    status_code=400, 
                    detail="data_ini e data_fim s√£o obrigat√≥rios para modo backfill"
                )
        
        # Publicar mensagem
        publisher = RabbitMQPublisher(settings.RABBITMQ_URL)
        await publisher.connect()
        success = await publisher.publish_sync_request(request)
        
        if success:
            return SyncResponse(
                success=True,
                message=f"Sync request published: {request.mode}",
                request_id=str(uuid.uuid4())
            )
        else:
            raise HTTPException(status_code=500, detail="Failed to publish request")
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### **5. Configura√ß√£o Docker Compose**

```yaml
# Adicionar ao docker-compose.yaml existente
backend:
  build:
    context: .
    dockerfile: Dockerfile.backend
  container_name: pncp-backend
  ports:
    - "8000:8000"
  depends_on:
    postgres:
      condition: service_healthy
    rabbitmq:
      condition: service_healthy
  environment:
    - DATABASE_URL=postgresql://pncp_user:pncp_pass@postgres:5432/pncp_ingestion
    - RABBITMQ_URL=amqp://admin:admin123@rabbitmq:5672/
    - LOG_LEVEL=INFO
  volumes:
    - ./backend:/app/backend
  restart: unless-stopped
```

### **6. Depend√™ncias (requirements-backend.txt)**

```txt
# FastAPI e servidor
fastapi==0.104.1
uvicorn[standard]==0.24.0

# RabbitMQ
aio-pika==9.3.1

# Database
sqlalchemy==2.0.23
asyncpg==0.29.0

# Valida√ß√£o
pydantic==2.5.0

# Utilit√°rios
python-dotenv==1.0.0
```

---

## üîÑ Fluxo de Integra√ß√£o

### **1. Request do Admin**
```bash
# Modo update
curl -X POST "http://localhost:8000/sync/force" \
  -H "Content-Type: application/json" \
  -d '{"mode": "update"}'

# Modo backfill
curl -X POST "http://localhost:8000/sync/force" \
  -H "Content-Type: application/json" \
  -d '{
    "mode": "backfill",
    "data_ini": "2025-01-10T12:00:00",
    "data_fim": "2025-01-10T18:00:00"
  }'
```

### **2. Processamento**
1. **Backend recebe** request via FastAPI
2. **Valida par√¢metros** com Pydantic
3. **Conecta ao RabbitMQ** e publica mensagem
4. **Ingestor consome** mensagem (j√° implementado)
5. **Processa ingest√£o** (j√° implementado)

### **3. Resposta**
```json
{
  "success": true,
  "message": "Sync request published: update",
  "request_id": "550e8400-e29b-41d4-a716-446655440000"
}
```

---

## üß™ Testes

### **1. Teste de Conectividade**
```python
async def test_rabbitmq_connection():
    """Testa conex√£o com RabbitMQ"""
    publisher = RabbitMQPublisher(settings.RABBITMQ_URL)
    await publisher.connect()
    assert publisher.connection is not None
```

### **2. Teste de Publica√ß√£o**
```python
async def test_publish_sync_request():
    """Testa publica√ß√£o de mensagem"""
    publisher = RabbitMQPublisher(settings.RABBITMQ_URL)
    await publisher.connect()
    
    request = SyncRequest(mode="update")
    success = await publisher.publish_sync_request(request)
    assert success is True
```

### **3. Teste de Valida√ß√£o**
```python
def test_backfill_validation():
    """Testa valida√ß√£o de par√¢metros backfill"""
    # Deve falhar sem data_ini/data_fim
    with pytest.raises(ValueError):
        SyncRequest(mode="backfill")
    
    # Deve funcionar com par√¢metros
    request = SyncRequest(
        mode="backfill",
        data_ini="2025-01-10T12:00:00",
        data_fim="2025-01-10T18:00:00"
    )
    assert request.mode == "backfill"
```

---

## üìä M√©tricas e Logs

### **1. Logs Estruturados**
```python
import logging

logger = logging.getLogger(__name__)

async def publish_sync_request(request: SyncRequest):
    logger.info(f"Publishing sync request: mode={request.mode}")
    
    try:
        # ... l√≥gica de publica√ß√£o
        logger.info(f"Sync request published successfully: {request.mode}")
        return True
    except Exception as e:
        logger.error(f"Failed to publish sync request: {e}")
        return False
```

### **2. M√©tricas**
- **Requests por minuto** via endpoint
- **Taxa de sucesso** de publica√ß√£o
- **Tempo de resposta** do endpoint
- **Erros de valida√ß√£o** por tipo

---

## üîß Configura√ß√£o de Ambiente

### **Vari√°veis de Ambiente**
```bash
# Backend Configuration
BACKEND_HOST=0.0.0.0
BACKEND_PORT=8000
BACKEND_RELOAD=true

# Database
DATABASE_URL=postgresql://pncp_user:pncp_pass@postgres:5432/pncp_ingestion

# RabbitMQ
RABBITMQ_URL=amqp://admin:admin123@rabbitmq:5672/

# Logging
LOG_LEVEL=INFO
```

### **Dockerfile.backend**
```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements-backend.txt .
RUN pip install -r requirements-backend.txt

COPY backend/ ./backend/

CMD ["uvicorn", "backend.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
```

---

## ‚úÖ Crit√©rios de Aceita√ß√£o

- [ ] **Backend FastAPI** rodando na porta 8000
- [ ] **Endpoint POST /sync/force** aceitando requests v√°lidos
- [ ] **Valida√ß√£o Pydantic** para par√¢metros obrigat√≥rios
- [ ] **Publisher RabbitMQ** publicando mensagens corretas
- [ ] **Integra√ß√£o Docker** com servi√ßos existentes
- [ ] **Testes** cobrindo casos principais
- [ ] **Logs estruturados** para debugging
- [ ] **Documenta√ß√£o** da API (Swagger autom√°tico)

---

## üîÑ Pr√≥ximos Passos

- [ ] **Tarefa 1.1.7** - Implementar endpoint /sync/status
- [ ] **Integra√ß√£o completa** com servi√ßo de ingest√£o
- [ ] **Monitoramento** e m√©tricas avan√ßadas
- [ ] **Autentica√ß√£o** para endpoints admin
