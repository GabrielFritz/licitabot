# [1.1.5] Salvar os dados extraídos no PostgreSQL [DONE]

---

## 🎯 Objetivo

Implementar a **persistência** dos dados extraídos da API PNCP no PostgreSQL:

1. **Serviço de persistência** (`services.persistence`) para salvar dados no banco
2. **Integração com ingestão** para salvar automaticamente os dados coletados
3. **Tratamento de duplicatas** e upserts inteligentes
4. **Validação básica** de dados antes da persistência
5. **Logs estruturados** de operações de banco

### Fluxo de Persistência

1. **Dados coletados** pela `ingest_window()` → **Serviço de persistência**
2. **Upsert inteligente** (insert/update baseado em chaves únicas)
3. **Transações** para garantir consistência
4. **Logs** de operações e métricas de performance

> **Foco**: Persistência robusta e integração com o fluxo de ingestão. A infraestrutura de banco já foi implementada na tarefa 1.1.4.

---

## ✅ Status: IMPLEMENTADO

### Funcionalidades Implementadas

- ✅ **Serviço de persistência** (`services.persistence`)
- ✅ **Integração com ingestão** (modificar `ingest_window`)
- ✅ **Upserts inteligentes** (insert/update baseado em chaves únicas)
- ✅ **Tratamento de duplicatas** e conflitos
- ✅ **Logs estruturados** de operações de banco
- ✅ **Testes de persistência**
- ✅ **Métricas de performance** (tempo de salvamento, registros processados)
- ✅ **Configuração flexível** via variáveis de ambiente
- ✅ **Modelos de banco otimizados** com `numero_controle_pncp` como chave primária
- ✅ **Configuração de logging SQL** para controle de verbosidade
- ✅ **Interface gráfica** (pgAdmin) para gerenciamento do banco

### Estrutura Final Implementada

```text
pncp_ingestion_service/
├── ingestor/
│   ├── services/
│   │   ├── ingestion.py          # Já implementado (atualizado com persistência)
│   │   └── persistence.py        # NOVO: Serviço de persistência (implementado)
│   ├── database/
│   │   ├── connection.py         # Já implementado (atualizado com SQL_LOGGING)
│   │   ├── models.py             # Já implementado (otimizado com numero_controle_pncp)
│   │   └── repositories/         # NOVO: Repositórios para cada entidade (implementado)
│   │       ├── __init__.py
│   │       ├── orgao_repository.py
│   │       ├── unidade_repository.py
│   │       ├── contratacao_repository.py
│   │       └── item_repository.py
│   └── config.py                 # Atualizado com variáveis de persistência e SQL_LOGGING
├── tests/
│   └── test_persistence.py       # NOVO: Testes de persistência (implementado)
├── docker-compose.yaml           # Atualizado com pgAdmin e PYTHONUNBUFFERED
├── env.local.example             # Atualizado com variáveis de persistência
└── requirements.txt              # Atualizado com dependências
```

### Componentes Implementados

#### **1. Repositórios (`database/repositories/`)**
- ✅ `OrgaoRepository` - Upsert de órgãos baseado no CNPJ
- ✅ `UnidadeRepository` - Upsert de unidades baseado no código
- ✅ `ContratacaoRepository` - Upsert de contratações e relacionamentos
- ✅ `ItemRepository` - Upsert em lote de itens

#### **2. Serviço de Persistência (`services/persistence.py`)**
- ✅ `persist_contratacao_with_items()` - Persistência completa de contratação
- ✅ `PersistenceResult` - Modelo de resultado estruturado (atualizado para usar `numero_controle_pncp`)
- ✅ `format_persistence_log()` - Formatação de logs informativos
- ✅ Tratamento de transações e rollback automático
- ✅ Logs detalhados com métricas de performance
- ✅ **Configuração de timeout** via variáveis de ambiente

#### **3. Integração com Ingestão**
- ✅ Modificação de `services/ingestion.py` para chamar persistência
- ✅ Logs estruturados com informações de sucesso/erro
- ✅ Tratamento de exceções durante persistência

#### **4. Configuração (`config.py`)**
- ✅ `PERSISTENCE_BATCH_SIZE` - Tamanho do lote para upserts
- ✅ `PERSISTENCE_TIMEOUT` - Timeout para operações de banco
- ✅ `PERSISTENCE_RETRY_ATTEMPTS` - Tentativas de retry
- ✅ `SQL_LOGGING` - Controle de verbosidade de logs SQL

#### **5. Modelos de Banco (`database/models.py`)**
- ✅ **Otimização de chaves primárias**: `numero_controle_pncp` como PK para `Contratacao`
- ✅ **Foreign keys atualizadas**: Todos os relacionamentos usam `numero_controle_pncp`
- ✅ **Eliminação de problemas de ID**: Não há mais necessidade de capturar IDs auto-gerados
- ✅ **Melhor performance**: Chaves naturais e significativas

#### **6. Configuração de Docker**
- ✅ `PYTHONUNBUFFERED=1` - Logs Python imediatos
- ✅ `pgAdmin` - Interface gráfica para gerenciamento do banco
- ✅ **Controle de verbosidade**: `SQL_LOGGING=false` por padrão

#### **7. Testes**
- ✅ `test_persistence.py` - Testes do serviço de persistência
- ✅ Cobertura de casos de sucesso e erro
- ✅ Testes de formatação de logs

### Logs Implementados

```text
[PERSIST] ✓ 88073291000199-1-000115/2025 — 10 itens salvos (orgao:✓, unidade:✓, amparo:✓, duration:110ms)
[PERSIST] ⚠️  07854402000100-1-000055/2025 — 3 itens salvos, 1 erro: "CNPJ inválido"
[PERSIST] ❌ 07854402000100-1-000056/2025 — Falha: "Timeout na conexão com banco"
```

### Evidência de Funcionamento

```text
[*] Initializing database tables...
[*] Database tables created successfully
[*] Listening on ingest.pncp …  Ctrl-C para sair
[ingestor] mode=update  window=2025-07-12T17:19:45 → 2025-07-12T17:34:45  (Δ=900s)
[PERSIST] ✓ 88073291000199-1-000115/2025 — 10 itens salvos (orgao:✓, unidade:✓, amparo:✓, duration:110ms)
```

---

## 📋 Especificações Técnicas

### **1. Serviço de Persistência (`services.persistence`)**

```python
async def persist_contratacao_with_items(
    contratacao: Contratacao,
    itens: List[ItemContratacao]
) -> PersistenceResult:
    """
    Persiste uma contratação com todos os seus itens.
    
    Fluxo:
    1. Upsert órgão e unidade
    2. Upsert amparo legal e fontes orçamentárias
    3. Upsert contratação
    4. Upsert todos os itens
    5. Commit transação
    """
```

### **2. Repositórios (`database/repositories/`)**

```python
class OrgaoRepository:
    async def upsert(self, orgao: OrgaoEntidade) -> OrgaoEntidade:
        """Upsert órgão baseado no CNPJ."""

class UnidadeRepository:
    async def upsert(self, unidade: UnidadeOrgao) -> UnidadeOrgao:
        """Upsert unidade baseado no código."""

class ContratacaoRepository:
    async def upsert(self, contratacao: Contratacao) -> Contratacao:
        """Upsert contratação baseado no numero_controle_pncp."""

class ItemRepository:
    async def upsert_batch(self, itens: List[ItemContratacao]) -> List[ItemContratacao]:
        """Upsert lote de itens."""
```

### **3. Modelo de Resultado**

```python
@dataclass
class PersistenceResult:
    success: bool
    numero_controle_pncp: Optional[str] = None  # Atualizado: usa string em vez de int
    itens_saved: int = 0
    orgao_upserted: bool = False
    unidade_upserted: bool = False
    amparo_upserted: bool = False
    fontes_upserted: int = 0
    duration_ms: float = 0.0
    errors: List[str] = field(default_factory=list)
```

### **4. Configuração de Ambiente**

```bash
# Persistence Configuration
PERSISTENCE_BATCH_SIZE=100
PERSISTENCE_TIMEOUT=30.0
PERSISTENCE_RETRY_ATTEMPTS=3

# Logging Configuration
SQL_LOGGING=false  # Controla verbosidade de logs SQL
LOG_LEVEL=INFO
PYTHONUNBUFFERED=1  # Logs Python imediatos
```

### **5. Modelos de Banco Otimizados**

```python
class Contratacao(Base):
    __tablename__ = "contratacoes"
    
    numero_controle_pncp = Column(String(100), primary_key=True)  # Chave primária natural
    # ... outros campos

class ItemContratacao(Base):
    __tablename__ = "itens_contratacao"
    
    numero_controle_pncp = Column(String(100), ForeignKey("contratacoes.numero_controle_pncp"))
    # ... outros campos
```

### **6. Integração com Ingestão**

```python
# Em services/ingestion.py
async def ingest_window() -> None:
    """Executa ingestão de dados do PNCP."""
    # ... código de coleta ...
    
    # Persistir dados coletados
    for contratacao in contratacoes:
        result = await persist_contratacao_with_items(contratacao, itens)
        log.info(format_persistence_log(result, contratacao.numero_controle_pncp))
```

---

## 🔧 Implementação

### **1. Repositórios**

Cada repositório implementa:
- **Upsert inteligente** baseado em chaves únicas
- **Tratamento de duplicatas** e conflitos
- **Transações** para garantir consistência
- **Logs** de operações de banco

### **2. Serviço de Persistência**

- **Orquestração** de todos os repositórios
- **Transações** para garantir atomicidade
- **Rollback automático** em caso de erro
- **Métricas** de performance e logs estruturados

### **3. Integração**

- **Modificação** de `services/ingestion.py`
- **Chamada** do serviço de persistência
- **Logs** informativos de sucesso/erro
- **Tratamento** de exceções durante persistência

### **4. Otimizações de Banco**

- **Chaves primárias naturais**: `numero_controle_pncp` como PK
- **Eliminação de problemas de ID**: Não há mais necessidade de capturar IDs
- **Melhor performance**: Chaves significativas e únicas
- **Controle de verbosidade**: `SQL_LOGGING` para logs limpos

---

## ✅ Testes

### **1. Testes de Persistência**

```bash
# Executar testes
python -m pytest tests/test_persistence.py -v
```

### **2. Cobertura de Testes**

- ✅ **Casos de sucesso** - Persistência completa
- ✅ **Casos de erro** - Tratamento de exceções
- ✅ **Upserts** - Verificação de duplicatas
- ✅ **Transações** - Rollback em caso de erro
- ✅ **Logs** - Formatação correta de mensagens
- ✅ **Modelos atualizados** - Testes com `numero_controle_pncp`

---

## 📊 Métricas

### **1. Performance**

- **Tempo médio** de persistência por contratação
- **Número de itens** salvos por operação
- **Taxa de sucesso** das operações de banco

### **2. Logs**

- **Formato estruturado** com informações detalhadas
- **Métricas de performance** (tempo, registros processados)
- **Tratamento de erros** com mensagens informativas
- **Controle de verbosidade** SQL para logs limpos

---

## 🛠️ Ferramentas de Gerenciamento

### **1. pgAdmin (Interface Gráfica)**
- **URL**: http://localhost:8080
- **Credenciais**: admin@pncp.com / admin123
- **Funcionalidades**: Visualização de dados, queries SQL, exportação

### **2. Configuração de Logs**
- **SQL_LOGGING=false**: Logs limpos sem verbosidade SQL
- **PYTHONUNBUFFERED=1**: Logs Python imediatos
- **LOG_LEVEL=INFO**: Nível apropriado de detalhamento

---

## 🚀 Próximos Passos

1. **Testes de integração** com dados reais da API
2. **Otimização de performance** para grandes volumes
3. **Monitoramento** de métricas de persistência
4. **Backup e recuperação** de dados
5. **Índices** para otimizar consultas frequentes
6. **Dashboards** para visualização de métricas
7. **Alertas** para falhas de persistência
