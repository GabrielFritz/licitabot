# [1.1.7] Criar endpoint /sync/status e /sync/force (admin)

---

## üéØ Objetivo

Implementar **endpoints administrativos** para monitoramento e controle da ingest√£o:

1. **Endpoint de status** (`GET /sync/status`) para monitorar execu√ß√µes
2. **Endpoint de controle** (`POST /sync/force`) para acionar ingest√£o
3. **Tabela de execu√ß√µes** para persistir hist√≥rico
4. **Servi√ßo de status** para consultar m√©tricas
5. **Autentica√ß√£o b√°sica** para endpoints admin

### Endpoints Administrativos

| Endpoint | M√©todo | Descri√ß√£o |
|----------|--------|-----------|
| `GET /sync/status` | GET | Status da √∫ltima execu√ß√£o |
| `POST /sync/force` | POST | For√ßar execu√ß√£o da ingest√£o |
| `GET /sync/history` | GET | Hist√≥rico de execu√ß√µes (opcional) |

> **Foco**: Monitoramento, controle administrativo e persist√™ncia de status. Integra√ß√£o com o backend da tarefa 1.1.2.

---

## üìã Especifica√ß√µes T√©cnicas

### **1. Tabela de Execu√ß√µes**

```sql
CREATE TABLE sync_executions (
    id SERIAL PRIMARY KEY,
    mode VARCHAR(10) NOT NULL,                    -- 'update' ou 'backfill'
    window_start TIMESTAMP,                       -- In√≠cio da janela processada
    window_end TIMESTAMP,                         -- Fim da janela processada
    status VARCHAR(10) NOT NULL,                  -- 'running', 'success', 'error'
    records_processed INTEGER DEFAULT 0,          -- Registros processados
    duration_seconds DECIMAL(10,2) DEFAULT 0.0,   -- Dura√ß√£o em segundos
    error_message TEXT,                           -- Mensagem de erro (se houver)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- √çndices para performance
CREATE INDEX idx_sync_executions_status ON sync_executions(status);
CREATE INDEX idx_sync_executions_created_at ON sync_executions(created_at);
```

### **2. Modelos Pydantic**

```python
from pydantic import BaseModel, validator
from typing import Optional, Literal
from datetime import datetime
from decimal import Decimal

class SyncStatus(BaseModel):
    last_execution: Optional[datetime] = None
    status: Literal["success", "error", "running", "idle"] = "idle"
    mode: Optional[Literal["update", "backfill"]] = None
    window_start: Optional[datetime] = None
    window_end: Optional[datetime] = None
    records_processed: int = 0
    duration_seconds: float = 0.0
    error_message: Optional[str] = None
    last_updated: Optional[datetime] = None

class SyncExecution(BaseModel):
    id: int
    mode: str
    window_start: Optional[datetime] = None
    window_end: Optional[datetime] = None
    status: str
    records_processed: int
    duration_seconds: float
    error_message: Optional[str] = None
    created_at: datetime
    updated_at: datetime

class SyncHistory(BaseModel):
    executions: list[SyncExecution]
    total_count: int
    success_count: int
    error_count: int
    running_count: int
```

### **3. Servi√ßo de Status**

```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, desc
from typing import Optional, List

class SyncStatusService:
    def __init__(self, db_session: AsyncSession):
        self.db = db_session
    
    async def get_last_execution(self) -> Optional[SyncExecution]:
        """Obt√©m a √∫ltima execu√ß√£o da ingest√£o"""
        query = select(SyncExecution).order_by(desc(SyncExecution.created_at)).limit(1)
        result = await self.db.execute(query)
        return result.scalar_one_or_none()
    
    async def get_current_status(self) -> SyncStatus:
        """Obt√©m status atual da ingest√£o"""
        last_exec = await self.get_last_execution()
        
        if not last_exec:
            return SyncStatus(status="idle")
        
        return SyncStatus(
            last_execution=last_exec.created_at,
            status=last_exec.status,
            mode=last_exec.mode,
            window_start=last_exec.window_start,
            window_end=last_exec.window_end,
            records_processed=last_exec.records_processed,
            duration_seconds=float(last_exec.duration_seconds),
            error_message=last_exec.error_message,
            last_updated=last_exec.updated_at
        )
    
    async def create_execution(self, mode: str, window_start: Optional[datetime] = None, 
                             window_end: Optional[datetime] = None) -> SyncExecution:
        """Cria nova execu√ß√£o"""
        execution = SyncExecution(
            mode=mode,
            window_start=window_start,
            window_end=window_end,
            status="running",
            records_processed=0,
            duration_seconds=0.0
        )
        self.db.add(execution)
        await self.db.commit()
        await self.db.refresh(execution)
        return execution
    
    async def update_execution(self, execution_id: int, status: str, 
                             records_processed: int = 0, duration_seconds: float = 0.0,
                             error_message: Optional[str] = None) -> SyncExecution:
        """Atualiza execu√ß√£o existente"""
        execution = await self.db.get(SyncExecution, execution_id)
        if execution:
            execution.status = status
            execution.records_processed = records_processed
            execution.duration_seconds = duration_seconds
            execution.error_message = error_message
            execution.updated_at = datetime.utcnow()
            await self.db.commit()
            await self.db.refresh(execution)
        return execution
    
    async def get_history(self, limit: int = 50) -> SyncHistory:
        """Obt√©m hist√≥rico de execu√ß√µes"""
        query = select(SyncExecution).order_by(desc(SyncExecution.created_at)).limit(limit)
        result = await self.db.execute(query)
        executions = result.scalars().all()
        
        # Calcular estat√≠sticas
        total_count = len(executions)
        success_count = sum(1 for e in executions if e.status == "success")
        error_count = sum(1 for e in executions if e.status == "error")
        running_count = sum(1 for e in executions if e.status == "running")
        
        return SyncHistory(
            executions=executions,
            total_count=total_count,
            success_count=success_count,
            error_count=error_count,
            running_count=running_count
        )
```

### **4. Endpoints FastAPI**

```python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.responses import JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession

app = FastAPI(title="PNCP Sync Admin API", version="1.0.0")

# Dependency para obter sess√£o do banco
async def get_db_session() -> AsyncSession:
    async with async_session() as session:
        yield session

@app.get("/sync/status")
async def get_sync_status(db: AsyncSession = Depends(get_db_session)):
    """Obt√©m status da √∫ltima execu√ß√£o"""
    try:
        service = SyncStatusService(db)
        status = await service.get_current_status()
        return status
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/sync/force")
async def force_sync(request: SyncRequest, db: AsyncSession = Depends(get_db_session)):
    """For√ßa execu√ß√£o da ingest√£o"""
    try:
        # Validar par√¢metros
        if request.mode == "backfill":
            if not request.data_ini or not request.data_fim:
                raise HTTPException(
                    status_code=400, 
                    detail="data_ini e data_fim s√£o obrigat√≥rios para modo backfill"
                )
        
        # Criar registro de execu√ß√£o
        service = SyncStatusService(db)
        execution = await service.create_execution(
            mode=request.mode,
            window_start=datetime.fromisoformat(request.data_ini) if request.data_ini else None,
            window_end=datetime.fromisoformat(request.data_fim) if request.data_fim else None
        )
        
        # Publicar mensagem no RabbitMQ
        publisher = RabbitMQPublisher(settings.RABBITMQ_URL)
        await publisher.connect()
        success = await publisher.publish_sync_request(request)
        
        if success:
            return SyncResponse(
                success=True,
                message=f"Sync request published: {request.mode}",
                request_id=str(execution.id)
            )
        else:
            # Marcar como erro se falhar
            await service.update_execution(
                execution.id, 
                status="error", 
                error_message="Failed to publish to RabbitMQ"
            )
            raise HTTPException(status_code=500, detail="Failed to publish request")
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/sync/history")
async def get_sync_history(limit: int = 50, db: AsyncSession = Depends(get_db_session)):
    """Obt√©m hist√≥rico de execu√ß√µes"""
    try:
        service = SyncStatusService(db)
        history = await service.get_history(limit=limit)
        return history
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

### **5. Integra√ß√£o com Ingestor**

```python
# Modificar o consumer.py para atualizar status
async def handle(message: IncomingMessage) -> None:
    async with message.process():
        # ... c√≥digo existente ...
        
        # Criar/atualizar status de execu√ß√£o
        execution_id = await create_sync_execution(mode, data_ini, data_fim)
        
        try:
            start_time = time.time()
            await ingest_window(data_fim=data_fim, data_ini=data_ini)
            duration = time.time() - start_time
            
            # Atualizar status como sucesso
            await update_sync_execution(
                execution_id, 
                status="success", 
                duration_seconds=duration,
                records_processed=total_records_processed
            )
        except Exception as e:
            # Atualizar status como erro
            await update_sync_execution(
                execution_id, 
                status="error", 
                error_message=str(e)
            )
            raise
```

### **6. Autentica√ß√£o B√°sica (Opcional)**

```python
from fastapi import HTTPException, Depends
from fastapi.security import HTTPBasic, HTTPBasicCredentials
import secrets

security = HTTPBasic()

def verify_admin_credentials(credentials: HTTPBasicCredentials = Depends(security)):
    """Verifica credenciais de admin"""
    is_admin = (
        credentials.username == settings.ADMIN_USERNAME and
        credentials.password == settings.ADMIN_PASSWORD
    )
    if not is_admin:
        raise HTTPException(
            status_code=401,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Basic"},
        )
    return credentials

@app.post("/sync/force")
async def force_sync(
    request: SyncRequest, 
    db: AsyncSession = Depends(get_db_session),
    credentials: HTTPBasicCredentials = Depends(verify_admin_credentials)
):
    # ... implementa√ß√£o ...
```

---

## üîÑ Fluxo de Monitoramento

### **1. Execu√ß√£o de Ingest√£o**
1. **Admin chama** `POST /sync/force`
2. **Backend cria** registro em `sync_executions` com status "running"
3. **Backend publica** mensagem no RabbitMQ
4. **Ingestor processa** e atualiza status via callback
5. **Admin consulta** `GET /sync/status` para acompanhar

### **2. Consulta de Status**
```bash
# Verificar status atual
curl -X GET "http://localhost:8000/sync/status"

# Resposta
{
  "last_execution": "2025-01-10T15:30:00",
  "status": "success",
  "mode": "update",
  "window_start": "2025-01-10T15:15:00",
  "window_end": "2025-01-10T15:30:00",
  "records_processed": 150,
  "duration_seconds": 45.2,
  "error_message": null,
  "last_updated": "2025-01-10T15:30:45"
}
```

### **3. Hist√≥rico de Execu√ß√µes**
```bash
# Verificar hist√≥rico
curl -X GET "http://localhost:8000/sync/history?limit=10"

# Resposta
{
  "executions": [
    {
      "id": 1,
      "mode": "update",
      "status": "success",
      "records_processed": 150,
      "duration_seconds": 45.2,
      "created_at": "2025-01-10T15:30:00"
    }
  ],
  "total_count": 1,
  "success_count": 1,
  "error_count": 0,
  "running_count": 0
}
```

---

## üß™ Testes

### **1. Teste de Status**
```python
async def test_get_sync_status():
    """Testa obten√ß√£o de status"""
    async with async_session() as session:
        service = SyncStatusService(session)
        status = await service.get_current_status()
        assert status.status in ["idle", "success", "error", "running"]
```

### **2. Teste de Cria√ß√£o de Execu√ß√£o**
```python
async def test_create_execution():
    """Testa cria√ß√£o de execu√ß√£o"""
    async with async_session() as session:
        service = SyncStatusService(session)
        execution = await service.create_execution("update")
        assert execution.mode == "update"
        assert execution.status == "running"
```

### **3. Teste de Atualiza√ß√£o**
```python
async def test_update_execution():
    """Testa atualiza√ß√£o de execu√ß√£o"""
    async with async_session() as session:
        service = SyncStatusService(session)
        execution = await service.create_execution("update")
        updated = await service.update_execution(
            execution.id, "success", records_processed=100, duration_seconds=30.0
        )
        assert updated.status == "success"
        assert updated.records_processed == 100
```

---

## üìä M√©tricas e Dashboard

### **1. M√©tricas Dispon√≠veis**
- **Taxa de sucesso** das execu√ß√µes
- **Tempo m√©dio** de execu√ß√£o
- **Registros processados** por execu√ß√£o
- **Frequ√™ncia** de execu√ß√µes
- **Erros** mais comuns

### **2. Dashboard B√°sico**
```python
@app.get("/sync/dashboard")
async def get_dashboard(db: AsyncSession = Depends(get_db_session)):
    """Dashboard com m√©tricas principais"""
    service = SyncStatusService(db)
    history = await service.get_history(limit=100)
    
    # Calcular m√©tricas
    total_executions = history.total_count
    success_rate = (history.success_count / total_executions * 100) if total_executions > 0 else 0
    avg_duration = sum(e.duration_seconds for e in history.executions) / total_executions if total_executions > 0 else 0
    
    return {
        "total_executions": total_executions,
        "success_rate": f"{success_rate:.1f}%",
        "avg_duration_seconds": f"{avg_duration:.1f}",
        "last_24h_executions": len([e for e in history.executions if e.created_at > datetime.now() - timedelta(days=1)]),
        "current_status": await service.get_current_status()
    }
```

---

## üîß Configura√ß√£o de Ambiente

### **Vari√°veis de Ambiente**
```bash
# Admin Authentication (opcional)
ADMIN_USERNAME=admin
ADMIN_PASSWORD=admin123

# Database
DATABASE_URL=postgresql://pncp_user:pncp_pass@postgres:5432/pncp_ingestion

# RabbitMQ
RABBITMQ_URL=amqp://admin:admin123@rabbitmq:5672/

# Logging
LOG_LEVEL=INFO
```

### **Migra√ß√£o do Banco**
```python
# Alembic migration para criar tabela sync_executions
"""Create sync_executions table

Revision ID: 001
Revises: 
Create Date: 2025-01-10 15:30:00.000000

"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    op.create_table(
        'sync_executions',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('mode', sa.String(length=10), nullable=False),
        sa.Column('window_start', sa.DateTime(), nullable=True),
        sa.Column('window_end', sa.DateTime(), nullable=True),
        sa.Column('status', sa.String(length=10), nullable=False),
        sa.Column('records_processed', sa.Integer(), nullable=False, default=0),
        sa.Column('duration_seconds', sa.DECIMAL(10,2), nullable=False, default=0.0),
        sa.Column('error_message', sa.Text(), nullable=True),
        sa.Column('created_at', sa.DateTime(), nullable=False, server_default=sa.func.now()),
        sa.Column('updated_at', sa.DateTime(), nullable=False, server_default=sa.func.now()),
        sa.PrimaryKeyConstraint('id')
    )
    
    # Criar √≠ndices
    op.create_index('idx_sync_executions_status', 'sync_executions', ['status'])
    op.create_index('idx_sync_executions_created_at', 'sync_executions', ['created_at'])

def downgrade():
    op.drop_table('sync_executions')
```

---

## ‚úÖ Crit√©rios de Aceita√ß√£o

- [ ] **Tabela sync_executions** criada no banco
- [ ] **Endpoint GET /sync/status** retornando status atual
- [ ] **Endpoint POST /sync/force** integrado com RabbitMQ
- [ ] **Servi√ßo de status** persistindo execu√ß√µes
- [ ] **Integra√ß√£o com ingestor** atualizando status
- [ ] **Valida√ß√£o de par√¢metros** para modo backfill
- [ ] **Testes** cobrindo casos principais
- [ ] **Logs estruturados** para debugging
- [ ] **Autentica√ß√£o b√°sica** (opcional)
- [ ] **Documenta√ß√£o** da API (Swagger autom√°tico)

---

## üîÑ Pr√≥ximos Passos

- [ ] **Integra√ß√£o completa** com backend da tarefa 1.1.2
- [ ] **Dashboard avan√ßado** com gr√°ficos
- [ ] **Alertas** por e-mail em caso de erro
- [ ] **M√©tricas avan√ßadas** com Prometheus/Grafana
- [ ] **Autentica√ß√£o JWT** mais robusta
